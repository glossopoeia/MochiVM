
BEGIN_TEST("Simple handle with no handlers besides the after closure.");

// main =
//   2 handle {
//     2 4 add-double
//   } with {
//     after => 1 add-double
//   }
//   sub-double

CONSTANT(NUMBER_VAL(2));
CONSTANT(NUMBER_VAL(4));
CONSTANT(NUMBER_VAL(1));

WRITE_INT_INST(CALL, 10, 1); // 5
WRITE_INT_INST(TAILCALL, 41, 2); //10

// main
WRITE_INST(CONSTANT, 3);
WRITE_BYTE(0, 3);

WRITE_INT_INST(CLOSURE, 37, 4); // 17
WRITE_BYTE(0, 4); // 18
WRITE_SHORT(0, 4); // 20

WRITE_INST(HANDLE, 5); // 21
WRITE_SHORT(6, 5); // 23
WRITE_INT(0, 5); // 27
WRITE_BYTE(0, 5); // 28
WRITE_BYTE(0, 5); // 29

WRITE_INST(CONSTANT, 6); //30
WRITE_BYTE(0, 6); // 31
WRITE_INST(CONSTANT, 7); // 32
WRITE_BYTE(1, 7); // 33
WRITE_INST(ADD, 8); // 34

WRITE_INST(COMPLETE, 9);
WRITE_INST(SUBTRACT, 10);
WRITE_INST(RETURN, 11); // 37

// ret1
WRITE_INST(CONSTANT, 12);
WRITE_BYTE(2, 12);
WRITE_INST(ADD, 13);
WRITE_INST(RETURN, 14); // 41

// end
WRITE_INST(ABORT, 15);
WRITE_BYTE(0, 15);

VERIFY_FRAMES(0);
VERIFY_STACK(1);
VERIFY_NUMBER(5.0);

END_TEST();




BEGIN_TEST("Handle with one single-shot resume handler and a closure with a parameter.");

// main =
//   handle {
//     3 4 raise! 6 div
//   } with {
//     raise! e => 2 e sub resume
//     after => 1 add
//   }

CONSTANT(NUMBER_VAL(3));
CONSTANT(NUMBER_VAL(4));
CONSTANT(NUMBER_VAL(6));
CONSTANT(NUMBER_VAL(2));
CONSTANT(NUMBER_VAL(1));

WRITE_INT_INST(CALL, 10, 1); // 5
WRITE_INT_INST(TAILCALL, 68, 2); //10

// main
WRITE_INT_INST(CLOSURE, 64, 4); // 15
WRITE_BYTE(0, 4);
WRITE_SHORT(0, 4); // 18

WRITE_INT_INST(CLOSURE, 50, 5); // 23
WRITE_BYTE(1, 5);
WRITE_SHORT(0, 5); // 26

WRITE_INST(HANDLE, 6); // 27
WRITE_SHORT(14, 6); // 29
WRITE_INT(0, 6); // 33
WRITE_BYTE(0, 6); // 34
WRITE_BYTE(1, 6); // 35

WRITE_INST(CONSTANT, 7); // 36
WRITE_BYTE(0, 7);
WRITE_INST(CONSTANT, 7); // 38
WRITE_BYTE(1, 7);

WRITE_INST(REACT, 7); // 40
WRITE_INT(0, 7); // 44
WRITE_BYTE(0, 7); // 45

WRITE_INST(CONSTANT, 7); // 46
WRITE_BYTE(2, 7);
WRITE_INST(DIVIDE, 7); // 48

WRITE_INST(COMPLETE, 8);
WRITE_INST(RETURN, 8); // 50

// raise1
WRITE_INST(CONSTANT, 9);
WRITE_BYTE(3, 9); // 52

WRITE_INST(FIND, 9); // 53
WRITE_SHORT(0, 9); // 55
WRITE_SHORT(1, 9); // 57
WRITE_INST(SUBTRACT, 9); // 58

WRITE_INST(FIND, 10); // 59
WRITE_SHORT(0, 10); // 61
WRITE_SHORT(0, 10); // 63
WRITE_INST(TAILCALL_CONTINUATION, 10); // 64

// ret1
WRITE_INST(CONSTANT, 12); // 65
WRITE_BYTE(4, 12);
WRITE_INST(ADD, 13);
WRITE_INST(RETURN, 14); // 68

// end
WRITE_INST(ABORT, 15); // 69
WRITE_BYTE(0, 15);

VERIFY_FRAMES(0);
VERIFY_STACK(2);
VERIFY_NUMBER(4.0);

END_TEST();




BEGIN_TEST("Handler with parameters and two actions.");

// main =
//   let counter = get! 1 add-double put! zap get! 1 add-double put!
//   2
//   handle s { counter }
//   with {
//     get! => s s resume
//     put! n => [] n resume
//     after => [] swap cons s cons
//   }

CONSTANT(NUMBER_VAL(2));
CONSTANT(NUMBER_VAL(1));

WRITE_INT_INST(CALL, 10, 1); // 5
WRITE_INT_INST(TAILCALL, 121, 2); //10

// main
WRITE_INST(CONSTANT, 3);
WRITE_BYTE(0, 3); // 12

WRITE_INT_INST(CLOSURE, 111, 3); // 17
WRITE_BYTE(0, 3);
WRITE_SHORT(0, 3); // 20

WRITE_INT_INST(CLOSURE, 99, 3); // 25
WRITE_BYTE(1, 3);
WRITE_SHORT(0, 3); // 28

WRITE_INT_INST(CLOSURE, 83, 3); // 33
WRITE_BYTE(0, 3);
WRITE_SHORT(0, 3); // 36

WRITE_INST(HANDLE, 4); // 37
WRITE_SHORT(6, 4); // 39
WRITE_INT(0, 4); // 43
WRITE_BYTE(1, 4); // 44
WRITE_BYTE(2, 4); // 45

WRITE_INT_INST(CALL, 52, 4); // 50

WRITE_INST(COMPLETE, 5);
WRITE_INST(RETURN, 5); // 52

// counter
WRITE_INST(REACT, 6);
WRITE_INT(0, 6); // 57
WRITE_BYTE(0, 6); // 58

WRITE_INST(CONSTANT, 6);
WRITE_BYTE(1, 6);
WRITE_INST(ADD, 6); // 61

WRITE_INST(REACT, 6);
WRITE_INT(0, 6); // 66
WRITE_BYTE(1, 6); // 65

WRITE_INST(ZAP, 6);
WRITE_INST(REACT, 6); // 69
WRITE_INT(0, 6); // 73
WRITE_BYTE(0, 6); // 74

WRITE_INST(CONSTANT, 6);
WRITE_BYTE(1, 6);
WRITE_INST(ADD, 6); // 77

WRITE_INST(REACT, 6);
WRITE_INT(0, 6); // 82
WRITE_BYTE(1, 6); // 83

// get1
WRITE_INST(FIND, 7);
WRITE_SHORT(0, 7); // 86
WRITE_SHORT(1, 7); // 88
WRITE_INST(FIND, 7);
WRITE_SHORT(0, 7); // 91
WRITE_SHORT(1, 7); // 93
WRITE_INST(FIND, 7);
WRITE_SHORT(0, 7); // 96
WRITE_SHORT(0, 7); // 98
WRITE_INST(TAILCALL_CONTINUATION, 7); // 99

// put1
WRITE_INST(LIST_NIL, 7);
WRITE_INST(FIND, 7); // 101
WRITE_SHORT(0, 7); // 103
WRITE_SHORT(1, 7); // 105
WRITE_INST(FIND, 7);
WRITE_SHORT(0, 7); // 108
WRITE_SHORT(0, 7); // 110
WRITE_INST(TAILCALL_CONTINUATION, 7); // 111

// after1
WRITE_INST(LIST_NIL, 8);
WRITE_INST(SWAP, 8); // 113
WRITE_INST(LIST_CONS, 8);
WRITE_INST(FIND, 8); // 115
WRITE_SHORT(0, 8); // 117
WRITE_SHORT(0, 8); // 119
WRITE_INST(LIST_CONS, 8);
WRITE_INST(RETURN, 8); // 121

// end
WRITE_INST(ABORT, 15);
WRITE_BYTE(0, 15);

END_TEST();